dnorm(3, mean = 0.3, sd = 1.3)
# Distribution
cdf <- CDF(dnorm, mean = 0.3, sd = 1.3)
cdf(3)
pnorm(3, mean = 0.3, sd = 1.3)
# Numeric quantile function
pnorm(numericQuantile(dnorm)(0.9))
numericQuantile(dnorm)(0.9)
source("~/Documents/University/PhD/Projects/solar-project/R/solarr/R/PDF.R")
source("~/Documents/University/PhD/Projects/solar-project/R/solarr/R/dsolarGHI.R")
qsolarGHI(c(0.05, 0.95), 7, 0.001, 0.9, function(x) dnorm(x))
# Random generator
rsolarGHI(10, 7, 0.001, 0.9, function(x) dnorm(x))
model$seasonal_data$Ct
Bologna$seasonal_data$Ct
Ct <- Bologna$seasonal_data$Ct
GHI <- purrr::map(Ct, ~rsolarGHI(1, .x, 0.001, 0.9, function(x) dnorm(x)))
plot(GHI, type="l")
plot(GHI, type="l")
plot(1:366, GHI, type="l")
GHI <- purrr::map(Ct, ~rsolarGHI(1, .x, 0.001, 0.9, function(x) dt(x)))
GHI <- purrr::map(Ct, ~rsolarGHI(1, .x, 0.001, 0.9, function(x) dsnorm(x)))
plot(1:366, GHI, type="l")
GHI <- purrr::map(Ct, ~rsolarGHI(1, .x, 0.001, 0.9, function(x) dsnorm(x, shape = 3)))
plot(1:366, GHI, type="l")
GHI <- purrr::map(Ct, ~rsolarGHI(1, .x, 0.001, 0.9, function(x) dsnorm(x, shape = -3)))
plot(1:366, GHI, type="l")
GHI <- purrr::map(Ct, ~rsolarGHI(1, .x, 0.001, 0.9, function(x) dsnorm(x, shape = -4)))
plot(1:366, GHI, type="l")
GHI <- purrr::map(Ct, ~rsolarGHI(1, .x, 0.001, 0.9, function(x) dsnorm(x, shape = -4)))
plot(1:366, GHI, type="l")
devtools::document()
devtools::build_manual()
optionPayoff <- function(x, strikes = 0, c0 = 0, put = TRUE){
payoff <- c()
put <- ifelse(put, -1, 1)
payoff <- (x - strike)*put
payoff[payoff<0] <- 0
payoff <- payoff - v0
return(payoff)
}
optionPayoff(c(1), c(2), c(3), put = c(T))
optionPayoff <- function(x, strike = 0, c0 = 0, put = TRUE){
payoff <- c()
put <- ifelse(put, -1, 1)
payoff <- (x - strike)*put
payoff[payoff<0] <- 0
payoff <- payoff - v0
return(payoff)
}
optionPayoff(c(1), c(2), c(3), put = c(T))
optionPayoff <- function(x, strike = 0, c0 = 0, put = TRUE){
payoff <- c()
put <- ifelse(put, -1, 1)
payoff <- (x - strike)*put
payoff[payoff<0] <- 0
payoff <- payoff - c0
return(payoff)
}
optionPayoff(c(1), c(2), c(3), put = c(T))
optionPayoff(c(1, 1), c(2, 2), c(3, 2), put = c(T, F))
optionPayoff(c(1, 1), c(2, 2), c(2, 2), put = c(T, F))
optionPayoff(1, c(2, 2), c(2, 2), put = c(T, F))
optionPayoff(10, 9, 1, put = TRUE)
mean(optionPayoff(seq(0, 20), 9, 1, put = TRUE))
#' @inheritParams solarModel_scenario
#'
#' @examples
#' spec <- solarModel_spec("Ferrara", from="2005-01-01", to="2020-01-01")
#' model <- solarModel(spec)
#' solarModel_simulate(model, from = "2010-01-01", to = "2010-12-31", nsim = 1)
#'
#' @rdname solarModel_simulate
#' @name solarModel_simulate
#' @export
solarModel_simulate <- function(model, from = "2010-01-01", to = "2010-12-31", nsim = 1, lambda = 0, seed = 1, exclude_known = FALSE, quiet = FALSE){
# Number of lags to consider
i_start <- model$control$mean.model$arOrder+1
data <- model$data
place <- model$place
# AR(2) model (GHI)
AR_model_Yt <- model$AR_model_Yt
NM_model <- model$NM_model
GARCH <- model$GARCH
params <- model$params
esscher_probability <- function(params = c(0,0,1,1,0.5), df_n, h = 0){
params <- list(
mu_up = df_n$Yt_bar + df_n$Yt_tilde_uncond + df_n$Yt_tilde_hat + df_n$sigma*df_n$sigma_bar*params[1],
mu_dw = df_n$Yt_bar + df_n$Yt_tilde_uncond + df_n$Yt_tilde_hat + df_n$sigma*df_n$sigma_bar*params[2],
sd_up = params[3]*df_n$sigma_bar*df_n$sigma,
sd_dw = params[4]*df_n$sigma_bar*df_n$sigma,
p_up = params[5]
)
params <- unlist(params)
num <- params[5]*exp(h*params[1] + (h^2*params[3]^2)/2)
den <- (1-params[5])*exp(h*params[2] + (h^2*params[4]^2)/2)
num/(num + den)
}
# Initial date
from <- as.Date(from)
# End date
to <- as.Date(to)
# Initialize a dataset
max_date_from <- max(data$date)
max_date_to <- max_date_from - i_start
if (max_date_to >= to) {
df_emp <- dplyr::filter(data, date >= (from - lubridate::days(i_start-1)) & date <= to)
df_emp <- dplyr::bind_cols(place = place, df_emp)
} else if (max_date_to >= from & max_date_from >= from) {
df_emp <- dplyr::filter(data, date >= (from - lubridate::days(i_start-1)))
df_new_emp <- dplyr::tibble(date = seq.Date(max(df_emp$date) + 1, to, by = "1 day"))
df_emp <- dplyr::bind_rows(df_emp, df_new_emp)
df_emp <- dplyr::select(df_emp, -dplyr::any_of(colnames(seasonal_data)[-c(1:2)]))
df_emp <- dplyr::mutate(df_emp,
Year = lubridate::year(date),
Month = lubridate::month(date),
Day = lubridate::day(date))
df_emp$n <- solarr::number_of_day(df_emp$date)
} else {
msg <- paste0("The maximum date for starting a simulation is: ", max_date_from)
if (!quiet) warning(msg)
return(model)
}
# Add seasonal data
seasonal_data <- dplyr::select(model$seasonal_data, Month, Day, Ct, Yt_bar, GHI_bar, sigma_bar)
df_emp <- dplyr::left_join(df_emp, seasonal_data, by = c("Month", "Day"))
df_emp <- dplyr::left_join(df_emp, model$monthly_data, by = c("Month"))
# Garch parameters
omega0 <- GARCH$coef[1]
omega1 <- GARCH$coef[2]
omega2 <- GARCH$coef[3]
# Initialize the template dataset
df_sim_init <- dplyr::left_join(df_emp, NM_model[, c("Month","mu_up", "mu_dw", "sd_up", "sd_dw", "p_up")], by = "Month")
# Filter df_emp to be in [from - to] dates
if (exclude_known) {
df_emp <- dplyr::filter(df_emp, date >= from & date <= to)
}
# Initialize Market risk premium
df_sim_init$lambda <- lambda
# Remove redundant variables
df_sim_init <- dplyr::select(df_sim_init, -clearsky, -isTrain)
j <- 1
simulations <- list()
for(j in 1:nsim){
# Initialize dataset for storing the simulation
df_sim <- df_sim_init
# Simulate Normal mixture (ut)
df_sim$u <- rnorm(nrow(df_sim), mean = 0, sd = 1)
if (!quiet) message("Simulation: ", j, "/", nsim, " (", round(j/nsim*100, 4), " %) \r", appendLF = FALSE)
set.seed(seed)
i <- i_start
for(i in i_start:nrow(df_sim)){
# Simulated GARCH standard deviation
df_sim$sigma[i] <- sqrt(omega0 + omega1*df_sim$eps_tilde[i-1]^2 + omega2*df_sim$sigma[i-1]^2)
# Simulated Yt_tilde
df_sim$Yt_tilde_hat[i] <- predict(AR_model_Yt, newdata = df_sim[(i-i_start):i,])[i_start]
if (lambda != 0) {
params <- c(df_sim$mu_up[i], df_sim$mu_dw[i], df_sim$sd_up[i], df_sim$sd_dw[i], df_sim$p_up[i])
df_sim$p_up[i] <- esscher_probability(params, df_n = df_sim[i,], h = lambda)
}
# Bernoulli jump
df_sim$B[i] <- rbinom(1, 1, df_sim$p_up[i])
# Simulated Esscher parameter
df_sim$lambda[i] <- df_sim$B[i]*(df_sim$sd_up[i]^2)*df_sim$lambda[i] + (1-df_sim$B[i])*(df_sim$sd_dw[i]^2)*df_sim$lambda[i]
df_sim$lambda[i] <- df_sim$lambda[i]*(df_sim$sigma[i]*df_sim$sigma_bar[i])^2
# Simulated normal mixture
df_sim$u_tilde[i] <- (df_sim$mu_up[i] + df_sim$sd_up[i]*df_sim$u[i])*df_sim$B[i] + (1-df_sim$B[i])*(df_sim$mu_dw[i] + df_sim$sd_dw[i]*df_sim$u[i])
# Simulated standardized monthly residuals
df_sim$u[i] <- df_sim$sigma_m[i]*df_sim$u_tilde[i]
# Simulated standardized residuals
df_sim$eps_tilde[i] <- df_sim$sigma[i]*df_sim$u[i]
# Simulated AR residuals
df_sim$eps[i] <- df_sim$eps_tilde[i]*df_sim$sigma_bar[i]
# Simulated Yt_tilde
df_sim$Yt_tilde[i] <- df_sim$Yt_tilde_hat[i] + df_sim$eps[i]
# Simulated Yt
df_sim$Yt[i] <- df_sim$Yt_bar[i] + df_sim$Yt_tilde[i] + df_sim$Yt_tilde_uncond[i] + df_sim$lambda[i]
# Simulated Xt
df_sim$Xt[i] <- model$transform$Yt(df_sim$Yt[i], inverse = TRUE)
# Simulated GHI
df_sim$GHI[i] <- model$transform$GHI(df_sim$Xt[i], df_sim$Ct[i])
}
# Remove redundant variables
df_sim <- dplyr::select(df_sim, -mu_up, -mu_dw, -sd_up, -sd_dw, -p_up, -Ct, -Yt_bar, -sigma_bar, -Yt_tilde_hat, -Yt_tilde_uncond, -lambda)
# Remove initial values
if (exclude_known) {
df_sim <- dplyr::filter(df_sim, date >= from & date <= to)
}
# Store simulations
simulations[[j]] <- dplyr::bind_cols(seed = seed, df_sim)
# Update seed
seed <- seed + j
}
# Remove redundant variables
df_emp <- dplyr::select(df_emp, -clearsky, -Yt_bar, -sigma_bar, -Yt_tilde_hat, -Yt_tilde_uncond, -isTrain)
structure(
list(
sim = simulations,
emp = df_emp,
params = list(seed = seed, from = from, to = to, nsim = nsim, lambda = lambda)
),
class = c("solarModelSimulation", "list")
)
}
spec <- solarModel_spec("Ferrara", from="2005-01-01", to="2020-01-01")
model <- solarModel(spec)
solarModel_simulate(model, from = "2010-01-01", to = "2010-12-31", nsim = 1)
#' @inheritParams solarModel_scenario
#'
#' @examples
#' spec <- solarModel_spec("Ferrara", from="2005-01-01", to="2020-01-01")
#' model <- solarModel(spec)
#' solarModel_simulate(model, from = "2010-01-01", to = "2010-12-31", nsim = 1)
#'
#' @rdname solarModel_simulate
#' @name solarModel_simulate
#' @export
solarModel_simulate <- function(model, from = "2010-01-01", to = "2010-12-31", nsim = 1, lambda = 0, seed = 1, exclude_known = FALSE, quiet = FALSE){
# Number of lags to consider
i_start <- model$control$mean.model$arOrder+1
data <- model$data
place <- model$place
# AR(2) model (GHI)
AR_model_Yt <- model$AR_model_Yt
NM_model <- model$NM_model
GARCH <- model$GARCH
params <- model$params
esscher_probability <- function(params = c(0,0,1,1,0.5), df_n, h = 0){
params <- list(
mu_up = df_n$Yt_bar + df_n$Yt_tilde_uncond + df_n$Yt_tilde_hat + df_n$sigma*df_n$sigma_bar*params[1],
mu_dw = df_n$Yt_bar + df_n$Yt_tilde_uncond + df_n$Yt_tilde_hat + df_n$sigma*df_n$sigma_bar*params[2],
sd_up = params[3]*df_n$sigma_bar*df_n$sigma,
sd_dw = params[4]*df_n$sigma_bar*df_n$sigma,
p_up = params[5]
)
params <- unlist(params)
num <- params[5]*exp(h*params[1] + (h^2*params[3]^2)/2)
den <- (1-params[5])*exp(h*params[2] + (h^2*params[4]^2)/2)
num/(num + den)
}
# Initial date
from <- as.Date(from)
# End date
to <- as.Date(to)
# Initialize a dataset
max_date_from <- max(data$date)
max_date_to <- max_date_from - i_start
if (max_date_to >= to) {
df_emp <- dplyr::filter(data, date >= (from - lubridate::days(i_start-1)) & date <= to)
df_emp <- dplyr::bind_cols(place = place, df_emp)
} else if (max_date_to >= from & max_date_from >= from) {
df_emp <- dplyr::filter(data, date >= (from - lubridate::days(i_start-1)))
df_new_emp <- dplyr::tibble(date = seq.Date(max(df_emp$date) + 1, to, by = "1 day"))
df_emp <- dplyr::bind_rows(df_emp, df_new_emp)
df_emp <- dplyr::select(df_emp, -dplyr::any_of(colnames(seasonal_data)[-c(1:2)]))
df_emp <- dplyr::mutate(df_emp,
Year = lubridate::year(date),
Month = lubridate::month(date),
Day = lubridate::day(date))
df_emp$n <- solarr::number_of_day(df_emp$date)
} else {
msg <- paste0("The maximum date for starting a simulation is: ", max_date_from)
if (!quiet) warning(msg)
return(model)
}
# Add seasonal data
seasonal_data <- dplyr::select(model$seasonal_data, Month, Day, Ct, Yt_bar, GHI_bar, sigma_bar)
df_emp <- dplyr::left_join(df_emp, seasonal_data, by = c("Month", "Day"))
df_emp <- dplyr::left_join(df_emp, model$monthly_data, by = c("Month"))
# Garch parameters
omega0 <- GARCH$coef[1]
omega1 <- GARCH$coef[2]
omega2 <- GARCH$coef[3]
# Initialize the template dataset
df_sim_init <- dplyr::left_join(df_emp, NM_model[, c("Month","mu_up", "mu_dw", "sd_up", "sd_dw", "p_up")], by = "Month")
# Filter df_emp to be in [from - to] dates
if (exclude_known) {
df_emp <- dplyr::filter(df_emp, date >= from & date <= to)
}
# Initialize Market risk premium
df_sim_init$lambda <- lambda
# Remove redundant variables
df_sim_init <- dplyr::select(df_sim_init, -clearsky, -isTrain)
j <- 1
simulations <- list()
for(j in 1:nsim){
# Initialize dataset for storing the simulation
df_sim <- df_sim_init
# Simulate Normal mixture (ut)
df_sim$u <- rnorm(nrow(df_sim), mean = 0, sd = 1)
if (!quiet) message("Simulation: ", j, "/", nsim, " (", round(j/nsim*100, 4), " %) \r", appendLF = FALSE)
set.seed(seed)
i <- i_start
for(i in i_start:nrow(df_sim)){
# Simulated GARCH standard deviation
df_sim$sigma[i] <- sqrt(omega0 + omega1*df_sim$eps_tilde[i-1]^2 + omega2*df_sim$sigma[i-1]^2)
# Simulated Yt_tilde
df_sim$Yt_tilde_hat[i] <- predict(AR_model_Yt, newdata = df_sim[(i-i_start):i,])[i_start]
if (lambda != 0) {
params <- c(df_sim$mu_up[i], df_sim$mu_dw[i], df_sim$sd_up[i], df_sim$sd_dw[i], df_sim$p_up[i])
df_sim$p_up[i] <- esscher_probability(params, df_n = df_sim[i,], h = lambda)
}
# Bernoulli jump
df_sim$B[i] <- rbinom(1, 1, df_sim$p_up[i])
# Simulated Esscher parameter
df_sim$lambda[i] <- df_sim$B[i]*(df_sim$sd_up[i]^2)*df_sim$lambda[i] + (1-df_sim$B[i])*(df_sim$sd_dw[i]^2)*df_sim$lambda[i]
df_sim$lambda[i] <- df_sim$lambda[i]*(df_sim$sigma[i]*df_sim$sigma_bar[i])^2
# Simulated normal mixture
df_sim$u_tilde[i] <- (df_sim$mu_up[i] + df_sim$sd_up[i]*df_sim$u[i])*df_sim$B[i] + (1-df_sim$B[i])*(df_sim$mu_dw[i] + df_sim$sd_dw[i]*df_sim$u[i])
# Simulated standardized monthly residuals
df_sim$u[i] <- df_sim$sigma_m[i]*df_sim$u_tilde[i]
# Simulated standardized residuals
df_sim$eps_tilde[i] <- df_sim$sigma[i]*df_sim$u[i]
# Simulated AR residuals
df_sim$eps[i] <- df_sim$eps_tilde[i]*df_sim$sigma_bar[i]
# Simulated Yt_tilde
df_sim$Yt_tilde[i] <- df_sim$Yt_tilde_hat[i] + df_sim$eps[i]
# Simulated Yt
df_sim$Yt[i] <- df_sim$Yt_bar[i] + df_sim$Yt_tilde[i] + df_sim$Yt_tilde_uncond[i] + df_sim$lambda[i]
# Simulated Xt
df_sim$Xt[i] <- model$transform$Yt(df_sim$Yt[i], inverse = TRUE)
# Simulated GHI
df_sim$GHI[i] <- model$transform$GHI(df_sim$Xt[i], df_sim$Ct[i])
}
# Remove redundant variables
df_sim <- dplyr::select(df_sim, -mu_up, -mu_dw, -sd_up, -sd_dw, -p_up, -Ct, -Yt_bar, -sigma_bar, -sigma_m, -Yt_tilde_hat, -Yt_tilde_uncond, -lambda)
# Remove initial values
if (exclude_known) {
df_sim <- dplyr::filter(df_sim, date >= from & date <= to)
}
# Store simulations
simulations[[j]] <- dplyr::bind_cols(seed = seed, df_sim)
# Update seed
seed <- seed + j
}
# Remove redundant variables
df_emp <- dplyr::select(df_emp, -clearsky, -Yt_bar, -sigma_bar, -sigma_m, -Yt_tilde_hat, -Yt_tilde_uncond, -isTrain)
structure(
list(
sim = simulations,
emp = df_emp,
params = list(seed = seed, from = from, to = to, nsim = nsim, lambda = lambda)
),
class = c("solarModelSimulation", "list")
)
}
solarModel_simulate(model, from = "2010-01-01", to = "2010-12-31", nsim = 1)
#' @inheritParams solarModel_scenario
#'
#' @examples
#' spec <- solarModel_spec("Ferrara", from="2005-01-01", to="2020-01-01")
#' model <- solarModel(spec)
#' solarModel_simulate(model, from = "2010-01-01", to = "2010-12-31", nsim = 1)
#'
#' @rdname solarModel_simulate
#' @name solarModel_simulate
#' @export
solarModel_simulate <- function(model, from = "2010-01-01", to = "2010-12-31", nsim = 1, lambda = 0, seed = 1, exclude_known = FALSE, quiet = FALSE){
# Number of lags to consider
i_start <- model$control$mean.model$arOrder+1
data <- model$data
place <- model$place
# AR(2) model (GHI)
AR_model_Yt <- model$AR_model_Yt
NM_model <- model$NM_model
GARCH <- model$GARCH
params <- model$params
esscher_probability <- function(params = c(0,0,1,1,0.5), df_n, h = 0){
params <- list(
mu_up = df_n$Yt_bar + df_n$Yt_tilde_uncond + df_n$Yt_tilde_hat + df_n$sigma*df_n$sigma_bar*params[1],
mu_dw = df_n$Yt_bar + df_n$Yt_tilde_uncond + df_n$Yt_tilde_hat + df_n$sigma*df_n$sigma_bar*params[2],
sd_up = params[3]*df_n$sigma_bar*df_n$sigma,
sd_dw = params[4]*df_n$sigma_bar*df_n$sigma,
p_up = params[5]
)
params <- unlist(params)
num <- params[5]*exp(h*params[1] + (h^2*params[3]^2)/2)
den <- (1-params[5])*exp(h*params[2] + (h^2*params[4]^2)/2)
num/(num + den)
}
# Initial date
from <- as.Date(from)
# End date
to <- as.Date(to)
# Initialize a dataset
max_date_from <- max(data$date)
max_date_to <- max_date_from - i_start
if (max_date_to >= to) {
df_emp <- dplyr::filter(data, date >= (from - lubridate::days(i_start-1)) & date <= to)
df_emp <- dplyr::bind_cols(place = place, df_emp)
} else if (max_date_to >= from & max_date_from >= from) {
df_emp <- dplyr::filter(data, date >= (from - lubridate::days(i_start-1)))
df_new_emp <- dplyr::tibble(date = seq.Date(max(df_emp$date) + 1, to, by = "1 day"))
df_emp <- dplyr::bind_rows(df_emp, df_new_emp)
df_emp <- dplyr::select(df_emp, -dplyr::any_of(colnames(seasonal_data)[-c(1:2)]))
df_emp <- dplyr::mutate(df_emp,
Year = lubridate::year(date),
Month = lubridate::month(date),
Day = lubridate::day(date))
df_emp$n <- solarr::number_of_day(df_emp$date)
} else {
msg <- paste0("The maximum date for starting a simulation is: ", max_date_from)
if (!quiet) warning(msg)
return(model)
}
# Add seasonal data
seasonal_data <- dplyr::select(model$seasonal_data, Month, Day, Ct, Yt_bar, GHI_bar, sigma_bar)
df_emp <- dplyr::left_join(df_emp, seasonal_data, by = c("Month", "Day"))
df_emp <- dplyr::left_join(df_emp, model$monthly_data, by = c("Month"))
# Garch parameters
omega0 <- GARCH$coef[1]
omega1 <- GARCH$coef[2]
omega2 <- GARCH$coef[3]
# Initialize the template dataset
df_sim_init <- dplyr::left_join(df_emp, NM_model[, c("Month","mu_up", "mu_dw", "sd_up", "sd_dw", "p_up")], by = "Month")
# Filter df_emp to be in [from - to] dates
if (exclude_known) {
df_emp <- dplyr::filter(df_emp, date >= from & date <= to)
}
# Initialize Market risk premium
df_sim_init$lambda <- lambda
# Remove redundant variables
df_sim_init <- dplyr::select(df_sim_init, -clearsky, -isTrain)
j <- 1
simulations <- list()
for(j in 1:nsim){
# Initialize dataset for storing the simulation
df_sim <- df_sim_init
# Simulate Normal mixture (ut)
df_sim$u <- rnorm(nrow(df_sim), mean = 0, sd = 1)
if (!quiet) message("Simulation: ", j, "/", nsim, " (", round(j/nsim*100, 4), " %) \r", appendLF = FALSE)
set.seed(seed)
i <- i_start
for(i in i_start:nrow(df_sim)){
# Simulated GARCH standard deviation
df_sim$sigma[i] <- sqrt(omega0 + omega1*df_sim$eps_tilde[i-1]^2 + omega2*df_sim$sigma[i-1]^2)
# Simulated Yt_tilde
df_sim$Yt_tilde_hat[i] <- predict(AR_model_Yt, newdata = df_sim[(i-i_start):i,])[i_start]
if (lambda != 0) {
params <- c(df_sim$mu_up[i], df_sim$mu_dw[i], df_sim$sd_up[i], df_sim$sd_dw[i], df_sim$p_up[i])
df_sim$p_up[i] <- esscher_probability(params, df_n = df_sim[i,], h = lambda)
}
# Bernoulli jump
df_sim$B[i] <- rbinom(1, 1, df_sim$p_up[i])
# Simulated Esscher parameter
df_sim$lambda[i] <- df_sim$B[i]*(df_sim$sd_up[i]^2)*df_sim$lambda[i] + (1-df_sim$B[i])*(df_sim$sd_dw[i]^2)*df_sim$lambda[i]
df_sim$lambda[i] <- df_sim$lambda[i]*(df_sim$sigma[i]*df_sim$sigma_bar[i])^2
# Simulated normal mixture
df_sim$u_tilde[i] <- (df_sim$mu_up[i] + df_sim$sd_up[i]*df_sim$u[i])*df_sim$B[i] + (1-df_sim$B[i])*(df_sim$mu_dw[i] + df_sim$sd_dw[i]*df_sim$u[i])
# Simulated standardized monthly residuals
df_sim$u[i] <- df_sim$sigma_m[i]*df_sim$u_tilde[i]
# Simulated standardized residuals
df_sim$eps_tilde[i] <- df_sim$sigma[i]*df_sim$u[i]
# Simulated AR residuals
df_sim$eps[i] <- df_sim$eps_tilde[i]*df_sim$sigma_bar[i]
# Simulated Yt_tilde
df_sim$Yt_tilde[i] <- df_sim$Yt_tilde_hat[i] + df_sim$eps[i]
# Simulated Yt
df_sim$Yt[i] <- df_sim$Yt_bar[i] + df_sim$Yt_tilde[i] + df_sim$Yt_tilde_uncond[i] + df_sim$lambda[i]
# Simulated Xt
df_sim$Xt[i] <- model$transform$Yt(df_sim$Yt[i], inverse = TRUE)
# Simulated GHI
df_sim$GHI[i] <- model$transform$GHI(df_sim$Xt[i], df_sim$Ct[i])
}
# Remove redundant variables
df_sim <- dplyr::select(df_sim, -mu_up, -mu_dw, -sd_up, -sd_dw, -p_up, -Ct, -Yt_bar, -sigma_bar, -sigma_m, -Yt_tilde_hat, -Yt_tilde_uncond, -lambda)
# Remove initial values
if (exclude_known) {
df_sim <- dplyr::filter(df_sim, date >= from & date <= to)
}
# Store simulations
simulations[[j]] <- dplyr::bind_cols(seed = seed, df_sim)
# Update seed
seed <- seed + j
}
# Remove redundant variables
df_emp <- dplyr::select(df_emp, -clearsky, -Ct, -Yt_bar, -sigma_bar, -sigma_m, -Yt_tilde_hat, -Yt_tilde_uncond, -isTrain)
structure(
list(
sim = simulations,
emp = df_emp,
params = list(seed = seed, from = from, to = to, nsim = nsim, lambda = lambda)
),
class = c("solarModelSimulation", "list")
)
}
solarModel_simulate(model, from = "2010-01-01", to = "2010-12-31", nsim = 1)
library(solarr)
library(solarr)
devtools::document()
spec <- solarModel_spec("Ferrara", from="2005-01-01", to="2020-01-01")
model <- solarModel(spec)
solarModel_scenario(model, from = "2010-01-01", to = "2010-12-31", nsim = 2, by = "1 month")
library(solarr)
devtools::document()
spec <- solarModel_spec("Ferrara", from="2005-01-01", to="2020-01-01")
model <- solarModel(spec)
solarModel_scenario(model, from = "2010-01-01", to = "2010-12-31", nsim = 2, by = "1 month")
solarOption_model(model)
solarOption_historical(model)
control <- control_solarModel(outliers_quantile = 0.000)
spec <- solarModel_spec("Berlino", from="2005-01-01", to="2024-01-01", control_model = control)
model <- solarModel(spec)
solarOption_model(model)
solarOption_historical(model)
control <- control_solarModel(outliers_quantile = 0.0005)
spec <- solarModel_spec("Berlino", from="2005-01-01", to="2024-01-01", control_model = control)
model <- solarModel(spec)
solarOption_model(model)
solarOption_historical(model)
devtools::document()
library(solarr)
